\documentclass{article}

\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{amsthm}
\usepackage[leqno]{amsmath}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{bookmark}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}
\usepackage{graphicx}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage{etoolbox}
\AtBeginEnvironment{align}{\setcounter{equation}{0}}


\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\newtheoremstyle{theorem}
  {\topsep}   % ABOVESPACE
  {\topsep}   % BELOWSPACE
  {\itshape\/}  % BODYFONT
  {0pt}       % INDENT (empty value is the same as 0pt)
  {\bfseries} % HEADFONT
  {.}         % HEADPUNCT
  {5pt plus 1pt minus 1pt} % HEADSPACE
  {}          % CUSTOM-HEAD-SPEC
\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{CPSC-354 Report}
\author{Brandon Hughes \\ Chapman University}

\date{\today} 

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents

\section{Introduction}\label{intro}

\section{Week by Week}\label{homework}

\subsection{Week 1}

\subsubsection{Notes}

During this week, there was a review of Git and being introduced to Latex and Lean. Some helpful commands include git add, commit, status, and push. 
Through the website "https://sudorealm.com/blog/how-to-write-latex-documents-with-visual-studio-code-on-mac", we set up latex to be able to complete the weekly report.

\subsubsection{Homework}

1. Finish the Natural Number Game Tutorial World. \\
\hspace*{2em}a) Show the completed work for levels 5 through 8. \\
\hspace*{2em}b) For one level, explain in detail how the Lean proof is related to its corresponding proof in mathematics. \\

1a. Show the completed work for levels 5 through 8. \\
Level 5: Prove that a+(b+0)+(c+0)=a+b+c.
\begin{lstlisting}
rw[add_zero]
rw[add_zero]
rfl
\end{lstlisting}

Level 6: Prove that a+(b+0)+(c+0)=a+b+c.
\begin{lstlisting}
repeat rw[add_zero]
rfl
\end{lstlisting}

Level 7: Prove that for all natural numbers a, we have succ(a)=a+1.
\begin{lstlisting}
rw[one_eq_succ_zero]
rw[add_succ]
rw[add_zero]
rfl
\end{lstlisting}

Level 8: Prove that 2+2=4.
\begin{lstlisting}
repeat rw[four_eq_succ_three, three_eq_succ_two, two_eq_succ_one, one_eq_succ_zero]
repeat rw[add_succ, add_succ, add_zero]
rfl
\end{lstlisting}

1b. For one level, explain in detail how the Lean proof is related to its corresponding proof in mathematics. \\
For level 7, we had to prove the therom of the succ(n) is also equal to n+1. 

Lean Proof:
\begin{lstlisting}
Start: succ(n) = n + 1
  1: rw[one_eq_succ_zero]
  Result: succ n = n + succ 0
  2: rw[add_succ]
  Result: succ n = succ (n + 0)
  3: rw[add_zero]
End: succ n = succ n

Thus, proving reflexitivity. 
\end{lstlisting}

Proof by Mathematics: By using the induction we are able to prove the therom of the succ(a) is equal to a+1.
\begin{lstlisting}
Base Case:
  Consider n = 0,

  S(0) = 0 + 1

  0 + 1 = 1

  Thus, 0 + 1 = S(0), which holds true.

Inductive hypothesis:

  Assume for some natural number k that k + 1 = S(k).

Inductive Step:

  We need to show that k + 1 + 1 = S(k + 1).

  (k + 1) + 1 = S(k + 1), by adding parenthesis

  S(k) + 1 = S(k + 1), by using the inductive hypothesis.

  S(k + 1) = S(k + 1), by using addition of successors.

Thus, proving reflexitivity.
\end{lstlisting}

Through these steps, we can see that the end goal of proving reflexitivity on both the Lean proof and its corresponding proof in mathematics. The similarites come from the lean proof and the inductive step however,
as they are similar steps in being able to prove the theorem. The lean proof is more straight forward because instead of proving it through a basis, inductive hypothesis, and inductive step, you only have to prove
it through rewriting the equation so that both sides are equal. Which is done through the indutive step of the mathematics proof. 

\subsubsection{Comments and Questions}

When looking at Formal Systems from the textbook, we are given this example of an impossible puzzle to solve. 
The MU problem, where you are given a set of rules and have to obtain MU from MI, however, its impossible because you can never end up without 
having an odd number of I's inside the string. When it comes to Formal systems, and solving them a lot of times people will look towards actually doing 
compared to trying to assess the logic behind this however computers, mostly AI, generally start at the logic. How might combining human intuition and AI's 
logical reasoning lead to more effective problem-solving strategies? Would we be able to solve problems quicker, our would AI's logical reasoning overtake the 
human trial and error method?

\subsection{Week 2}

\subsubsection{Notes}

During this week, we learned in class that both Math and Lean can be seen as langauges. Math is a specification language while Lean is a programming language. A
specification langauge is used to define the requirements and properties of a system. A Math proof can be written into Lean proof very easily since they use and
follow the same rules when it comes to solving thoerems and problems. The difference between the two proofs however is that in Math we typically reason forwards
from the problem to the answer, while in Lean we reason backwards from the answer to the problem. We could also do it the opposite way but it would become more
challengening. Another idea that we learned in class is that a recursive data type, which could also be called an algebraic data type, and induction are of 
similar processes as you define what a number is inside of a number. An example of recursion can be seen in the Tower of Hanoi as you are solving the previous
tree in the next tree. Tower of Hanoi are also similar to binary search trees since the amount of nodes in a amount of 'n' level of a tree, if you have a balanced
tree is the same amount of moves it takes to solve when you have ;n' amount of disks. Lastly, we also learned that when you write a recursive program it creates 
a stack behind the scenes to solve all the problems, it will always go to the one on top rather than starting back at the start of the problem. If you don't have
a stack you could also write it on a rewriting machine.

\subsubsection{Homework}

1. Finish the Natural Number Game Addition World. \\
\hspace*{2em}a) Show the completed work for levels 1 through 5. \\
\hspace*{2em}b) For level 4 or 5, explain in some detail how the Lean proof is related to its corresponding proof in mathematics \\

1a.\\
Level 1:
\begin{align*}
  Sd&=Sd & \texttt{rfl} \\
  S(0+d)&=Sd & \texttt{rw[hd]} \\
  0+Sd &= Sd & \texttt{rw[add\_succ]} \\
  0&=0 & \texttt{rfl} \\
  0+0 &= 0 & \texttt{rw[add\_zero]} \\
  0+n &= n & \texttt{induction n with d hd} \\
\end{align*}

Level 2:
\begin{align*}
  SS(a+d)&=SS(a+d) & \texttt{rfl} \\
  S(Sa+d)&=SS(a+d) & \texttt{hd} \\
  S(Sa+d)&=S(a+Sd) & \texttt{rw[add\_succ]} \\
  Sa+Sd&=S(a+Sd) & \texttt{rw[add\_succ]} \\
  Sa&=Sa & \texttt{rfl} \\
  Sa&=S(a+0) & \texttt{rw[add\_zero]} \\
  Sa+0&=S(a+0) & \texttt{rw[add\_zero]} \\
  Sa+b&=S(a+b) & \texttt{induction b with d hd} \\
\end{align*}

Level 3:
\begin{align*}
  S(d+a)&=S(d+a) & \texttt{rfl} \\
  S(a+d)&=S(d+a) & \texttt{rw[hd]} \\
  S(a+d)&=Sd+a & \texttt{rw[succ\_add]} \\
  a+Sd&=Sd+a & \texttt{rw[add\_succ]} \\
  a&=a & \texttt{rfl} \\
  a&=0+a & \texttt{rw[zero\_add]} \\
  a+0&=0+a & \texttt{rw[add\_zero]} \\
  a+b&=b+a & \texttt{induction b with d hd} \\
\end{align*}

Level 4:
\begin{align*}
  S(a+(b+d))&=S(a+(b+d)) & \texttt{rfl} \\
  S(a+b+d)&=S(a+(b+d)) & \texttt{rw[hd]} \\
  S(a+b+d)&=a+S(b+d) & \texttt{rw[add\_succ]} \\
  S(a+b+d)&=a+(b+Sd) & \texttt{rw[add\_succ]} \\
  a+b+Sd&=a+(b+Sd) & \texttt{rw[add\_succ]} \\
  a+b&=a+b & \texttt{rfl} \\
  a+b&=a+(b+0) & \texttt{rw[add\_zero]} \\
  a+b+0&=a+(b+0) & \texttt{rw[add\_zero]} \\
  a+b+c&=a+(b+c) & \texttt{induction c with d hd} \\
\end{align*}

Level 5:
\begin{align*}
  S(a+d+b)&=S(a+d+b) & \texttt{rfl} \\
  S(a+b+d)&=S(a+d+b)  & \texttt{rw[hd]} \\
  S(a+d+b)&=S(a+d)+b & \texttt{rw[succ\_add]} \\
  S(a+d+b)&=a+Sd+b & \texttt{rw[add\_succ]} \\
  a+b+Sd&=a+Sd+b & \texttt{rw[add\_succ]} \\
  a+b&=a+b & \texttt{rfl} \\
  a+b&=a+0+b & \texttt{rw[add\_zero]} \\
  a+b+0&=a+0+b & \texttt{rw[add\_zero]} \\
  a+b+c&=a+c+b & \texttt{induction c with d hd} \\
\end{align*}

1b. \\

For Level 4, we are proving the associativity of addition. 
On the set of natural numbers, addition is associative. 
In other words, if a,b and c are arbitrary natural numbers, we have (a+b)+c=a+(b+c).
In Math and Lean, we have to do a proof by induction on c.\\ 

Math Proof:\\ 
\begin{align*}
  (a+b)+c&=a+(b+c) \\
\end{align*}
Base Case: $(a+b)+0=a+(b+0)$\\ 
\begin{align*}
  (a+b)+0&=a+(b+0)\\
  a+b&=a+(b+0) & \text{ def of } +\\
  a+b&=a+b & \text{ def of } +\\
\end{align*}

Induction Step: $(a+b)+Sd=a+(b+Sd)$ \\

Induction Hypothesis: $(a+b)+d=a+(b+d)$ \\

\begin{align*}
  (a+b)+Sd&=a+(b+Sd)\\
  S((a+b)+d)&=a+(b+Sd) & \text{ def of } +\\
  S((a+b)+d)&=a+S(b+d) & \text{ def of } +\\
  S((a+b)+d)&=S(a+(b+d)) & \text{ def of } +\\
  S(a+(b+d))&=S(a+(b+d)) & \text{ Induction Hypothesis}\\
\end{align*}

The Lean proof written above is the exact same as the same steps in the Math proof just backwards. 
Instead of having add\_zero and add\_succ, we have the definition of addition as that can be proven to add both 
successors and zero to numbers.  

\subsubsection{Comments and Questions}

In the beginning of the reading, it takes about how recursion is different from paradox or infinite regress, since it  never defines somethin in terms of iteself, but always in terms of simpler versions of itself. Is the only difference between a paradox and a recursively solveable problem be that it has an exit statement at its very simplest version or are there more differences? If some paradoxs were proposed recursively, would we be able to break down some harder problems into simpler version to prove if they are unsolveable logically?

\subsection{Week 3}

\subsubsection{Homework}

For this homework assignment, I used ChatGPT to explore language interoperability, which refers to how different programming languages interact with one another to create a single system or application. In modern software development and application creation, it is common for multiple programming languages to be used together to meet different kinds of functions and performance requirements. As a result, being able to integrate between these languages flawless is essential for building efficient  and reliable systems. This report goes over some of the current methods used to ensure compatibility between programming languages and investigates ways to enhance these systems further. While many languages already possess some interoperability with one another, challenges arise when trying to bridge the gaps between the languages that were not designed to work together. These challenges can lead to issues such as performance inefficiencies, data type mismatches, and increase complexity in code maintenance. By examining these difficulties, potential improvements can be seen to create more solutions for the future. Additionally, advancements in tools, frameworks, and compiler technology could further enhance interoperability efforts. By improving in ways in which programming languages collaborate, developers will be able to build more versatile, efficient, and scalable systems. Addressing these challenges and making enhancements will lead to more seamless development processes and better applications.  

\url{https://github.com/Brandon-Hughes/LLM_Literature_Review}



\subsection{Week 4}

\subsubsection{Notes}

Concrete syntax considers a program as a string in the form of a sequence of characters. This is the syntax that we are used to seeing and interacting with on a day to day basis. 
Abstract syntax considers a program as a tree-like structure that represents the program's structure and organization. 
An Abstract Syntax Tree (AST) is a tree representation of the abstract syntactic structure of source code written in a programming language. 
ASTs can write type checkers, interpreters, and compilers via recursion on these algebraic data types, but translating strings into trees is very difficult.
The main idea is that you can translate a concrete syntax (string) into a concrete syntax tree, but translating a concrete syntax tree (string) into an abstract syntax tree (tree) is very difficult.
Parsing is about putting the parentheses in the correct position.
A context-free grammar is a set of rules that describe how to form strings in a language.
The purpose of a context-free grammar is to define a set of strings or a language, in which a particular string in the lanaguage can be derived from the start symbol. The symbols that will appear in the strings (terminals), are those that are enclosed in single quotes.
Other symbols may never appear in the parsed string, but only control which strings can be derived. These are called non-terminals.


\subsubsection{Homework}
Using the context-free grammar: 
\begin{align*}
Exp &\rightarrow Exp + Exp1 \\
Exp1 &\rightarrow Exp1 \* Exp2 \\
Exp2 &\rightarrow Integer \\
Exp2 &\rightarrow ( Exp )  \\
Exp &\rightarrow Exp1 \\
Exp1 &\rightarrow Exp2 \\    
\end{align*}

Generate the abstract syntax tree for the expressions. \\
1. 2+1 \\
2. 1+2\*3 \\
3. 1+\(2\*3\) \\
4. \(1+2\)\*3 \\
5. 1+2\*3+4\*5+6 \\

\noindent
The Abstract Syntax Trees for Problems 1 through 5 are shown below:

\includegraphics[width=0.8\textwidth]{img/HW4.jpg}

As we can see from the image above, each of the problems can be solved by using the rules of the context-free grammar with the start symbol Exp.

\subsubsection{Comments and Questions}

During this week we've explored the idea of applying context-free grammar in the basics of Math and we are going to start applying that into programming languages. Besides the usage in math and programming lanaguages, are we able to see or use context-free grammar in other examples or in our lives?

\subsection{Week 5}

\subsubsection{Notes}

By practicing the application of context-free grammars (CFG) in a programming language, a calculator was created that took an input and broke it down into an Abstract Syntax Tree (AST) using a CFG. By breaking the expression into a AST, the problem was solved by reading through the AST to produce a correct result for the expression. This application served to practice parsing expressions into smaller pieces that are more easily read by programming languages, as well as provide an introduction to context-free grammars.

The second portion of this class week focused on an introduction and tutorial of constructive logic. Through the Lean logic game, students were introduced to how to write math expressions as logic-driven trees, similar to how a CFG might break an expression into components. While the process is similar, it differs by working with logical inferences instead of numbers. The keyword "exact" is used to give the game's answer, which serves as the concluding statement. The symbol $\wedge$ denotes a logical "and," meaning the logic must follow both A and B. The logical "and" can be broken apart using the keywords ".left" and ".right" to access either the left or right item of the $\wedge$, respectively.

\subsubsection{Homework}

1. Finish the Lean Logic Game Tutorial World. \\
\hspace*{2em}a) Show the completed work for levels 1 through 8. \\
\hspace*{2em}b) For level 8, write down the proof in mathematical logic.\\

1a.\\
Level 1: If todo\_list is P, then P.
\begin{align*}
  \text{exact todo\_list}
\end{align*}

Level 2: If p is P and s is S, then P $\wedge$ S.
\begin{align*}
  \text{exact $\langle$p,s$\rangle$}
\end{align*}

Level 3: If a is A, i is I, o is O, and u is U, then A $\wedge$ I $\wedge$ O $\wedge$ U.
\begin{align*}
  \text{exact $\langle$a,$\langle$i,$\langle$o,u$\rangle$$\rangle$$\rangle$}
\end{align*}

Level 4: If vm is P $\wedge$ S, then P.
\begin{align*}
  \text{exact vm.left}
\end{align*}

Level 5: If h is P $\wedge$ Q, then Q.
\begin{align*}
  \text{exact vm.right}
\end{align*}

Level 6: If h1 is A $\wedge$ I and h2 is O $\wedge$ U, then A $\wedge$ U.
\begin{align*}
  \text{exact $\langle$h1.left,h2.right$\rangle$}
\end{align*}

Level 7: If h is (L $\wedge$ ((L $\wedge$ C) $\wedge$ L) $\wedge$ L $\wedge$ L $\wedge$ L), then C.
\begin{align*}
  \text{exact h.left.right.left.left.right}
\end{align*}

1b. 

Level 8: If ((P $\wedge$ S) $\wedge$ A) $\wedge$ $\neg$I $\wedge$ (C $\wedge$ $\neg$O) $\wedge$ $\neg$U then A $\wedge$ C $\wedge$ P $\wedge$ S

\begin{align}
  \text{assumption1} &: ((P \wedge S) \wedge A) \wedge \neg I \wedge (C \wedge \neg O) \wedge \neg U & \text{} \\
  A && \text{and\_left and\_right on (1)} \\
  C && \text{and\_right and\_right and\_left and\_left on (1)} \\
  P && \text{and\_left and\_left and\_left on (1)} \\
  S && \text{and\_left and\_left and\_right on (1)} \\
  A \wedge C \wedge P \wedge S && \text{and\_intro on (2) (3) (4) (5)}
\end{align}

\subsubsection{Comments and Questions}

In the creation of a context-free grammar, we can see that by establishing a hierarchy through constructs like exp, exp1, exp2, etc., we can control the order of operations. How can programmers determine how deep the hierarchy should go to ensure the grammar is well-structured and the language doesn't break?

\subsection{Week 6}

\subsubsection{Notes}

Lambda calculus is a programming language comprised of only variables and functions. Two main portions build lambda calculus, the syntax and the semantics. The syntax is made of three constructions abstraction, application, and variables. Abstraction is taking the program and using a placeholder variable so that it can change what you use. It's the creation of general-purpose functions that can take in many different inputs but will produce a structured output. Application is how we apply functions to one another. Lastly, variables are just variables. An important part of Lambda calculus is dropping the parenthesis for easier readability. You apply the left and move to the right to solve for lambda in the same parenthesis. The next portion of Lambda calculus is the semantics or how to execute it. By executing, we are either inputting numbers into variables or simplifying them into their lowest form. When having multiple inputs and variables within the same expression, apply it in the same parentheses or the farthest lambda to the left if you only have the function in one parenthesis but multiple inputs and variables. When solving problems, you may arrive at to capture avoiding substitution, when multiple inputs are being placed into a variable, many solutions act differently here it will place it into all of them while some of them place it only into the first variable possible. To solve this, they created bound and free variables where bound variables are set within the function at the beginning, while free variables are those that are inputted. 

\subsubsection{Homework}

Finish the Lean Logic Game Tutorial World. Show the completed work for levels 1 through 9. \\

Level 1: If bakery\_service is P $\rightarrow$ C, then C.
\begin{align*}
  \text{exact bakery\_service \, p}
\end{align*}

Level 2: Show that C $\rightarrow$ C.
\begin{align*}
  \text{exact } \lambda h \Rightarrow h
\end{align*}

Level 3: Show that I $\wedge$ S $\rightarrow$ S $\wedge$ I.
\begin{align*}
  \text{exact } \lambda h \Rightarrow \langle h.right , h.left\rangle
\end{align*}

Level 4: If h1 is C $\rightarrow$ A and h2 is A $\rightarrow$ S, show that C $\rightarrow$ S.
\begin{align*}
  \text{exact } \lambda c \Rightarrow h2 (h1 \, c)
\end{align*}

Level 5: If h1 is P $\rightarrow$ Q, h2 is Q $\rightarrow$ R, h3 is Q $\rightarrow$ T, h4 is S $\rightarrow$ T, and h5 is T $\rightarrow$ U, then U.
\begin{align*}
  \text{exact } h5 (h3 (h1 \, p))
\end{align*}

Level 6: If h is C $\wedge$ D $\rightarrow$ S, then C $\rightarrow$ D $\rightarrow$ S.
\begin{align*}
  \text{exact } \lambda c \, d \Rightarrow h \langle c, d \rangle
\end{align*}

Level 7: If h is C $\rightarrow$ D $\rightarrow$ S, then C $\wedge$ D $\rightarrow$ S.
\begin{align*}
  \text{exact } \lambda \langle c, d \rangle \Rightarrow h \, c \, d
\end{align*}

Level 8: If h is (S $\rightarrow$ C) $\wedge$ (S $\rightarrow$ D), then S $\rightarrow$ C $\wedge$ D.
\begin{align*}
  \text{exact } \lambda s \Rightarrow \langle h.left \, s, h.right \, s \rangle
\end{align*}

Level 9: Show that R $\rightarrow$ (S $\rightarrow$ R) $\wedge$ ($\neg$ S $\rightarrow$ R).
\begin{align*}
  \text{exact } \lambda r \Rightarrow \langle \lambda s \Rightarrow r, \lambda s \Rightarrow r \rangle
\end{align*}

\subsubsection{Comments and Questions}
What are some alternative solutions to capture-avoiding substitution beyond using bound and free variables?

\ldots

\section{Lessons from the Assignments}

\section{Conclusion}\label{conclusion}

\begin{thebibliography}{99}
\bibitem[label]{citekey} Andrew Moshier, \href{https://canvas.chapman.edu/courses/66029/files/6581500?module_item_id=2280521}{Contemporary Discrete Mathematics}, M\&H Publishing, 2024
\end{thebibliography}

\end{document}